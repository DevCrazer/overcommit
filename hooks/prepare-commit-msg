#!/bin/sh
#
# prepare-commit-msg
#
# Called with 2 or 3 parameters: FILE SOURCE [SHA1]
#
# FILE    name of file containing the commit log message
# SOURCE  source of the message, which can be:
#         - message (if -m or -F option was given)
#         - template (via -t option or commit.template configuration)
#         - merge (if commit is a merge or .git/MERGE_MSG file exists)
#         - squash (if a .git/SQUASH_MSG file exists)
#         - commit
# SHA1    only present if SOURCE is "commit" and -c, -C or --amend option was given

# if submodule changes staged
# (may need to list all submodules)
# get revs via:


FILE="$1"
SOURCE=$2
SHA1=$3

if [ -n "$SHA1" ]; then
  OTHER="$SHA1~1"

  # beware of --amend/-c/-C commits which are really merges
  SHA1_AND_PARENTS=$(git rev-list -n 1 --parents $SHA1 | wc -w | tr -d ' ')
  if [ "$SHA1_AND_PARENTS" != "2" ]; then
    SOURCE=merge
  fi
else
  OTHER=HEAD
fi

# do nothing if there are no submodule changes staged
git diff-index --cached $OTHER | grep -q -e '^:160000' || exit 0

SUBMODULE_CHANGES=$(git submodule summary --cached $OTHER)
TMP_FILE=$(mktemp /tmp/$USER.prepare-commit-msg.XXXXXX)

prepend_submodule_changes() {
  # note trailing newline after submodule changes
  echo "$SUBMODULE_CHANGES
" | cat - "$FILE" > $TMP_FILE && cp $TMP_FILE "$FILE"
}

append_submodule_changes() {
  # note leading newline before submodule changes
  echo "
$SUBMODULE_CHANGES" >> "$FILE"
}

strip_submodule_changes() {
  # looking to remove listing that looks like:
  #
  #     * path abbreviated-SHA1...abbreivated-SHA1 (count):
  #       > oneline commit message
  true
}

case "$SOURCE" in
  commit)
    if [ -n "$SHA1" ]; then
      strip_submodule_changes
    fi
    append_submodule_changes
    ;;
  merge)
    # no recording done for merge commits (we assume that the parent commits
    # in the merge will have had their submodule changes recorded in them)
    ;;
  message)
    append_submodule_changes
    ;;
  squash|template)
    prepend_submodule_changes
    ;;
  *)
    ;;
esac
