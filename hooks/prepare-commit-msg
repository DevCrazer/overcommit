#!/bin/sh
#
# prepare-commit-msg
#
# Called with 2 or 3 parameters: FILE SOURCE [SHA1]
#
# FILE    name of file containing the commit log message
# SOURCE  source of the message, which can be:
#         - message (if -m or -F option was given)
#         - template (via -t option or commit.template configuration)
#         - merge (if commit is a merge or .git/MERGE_MSG file exists)
#         - squash (if a .git/SQUASH_MSG file exists)
#         - commit (if a -c, -C or --amend option was given)
# SHA1    only present if SOURCE is "commit"

FILE="$1"
SOURCE=$2
SHA1=$3

if [ -n "$SHA1" ]; then
  OTHER="$SHA1~1"

  # beware of --amend/-c/-C commits which are really merges
  SHA1_AND_PARENTS=$(git rev-list -n 1 --parents $SHA1 | wc -w | tr -d ' ')
  if [ "$SHA1_AND_PARENTS" != "2" ]; then
    SOURCE=merge
  fi
else
  OTHER=HEAD
fi

# do nothing if there are no submodule changes staged
git diff-index --cached $OTHER | grep -q -e '^:160000' || exit 0

SUBMODULE_CHANGES=$(git submodule summary --cached $OTHER)
TMP_FILE=$(mktemp /tmp/$USER.prepare-commit-msg.XXXXXX)

prepend_submodule_changes() {
  # note trailing newline after submodule changes
  echo "$SUBMODULE_CHANGES
" | cat - "$FILE" > $TMP_FILE && cp $TMP_FILE "$FILE"
}

append_submodule_changes() {
  # note leading newline before submodule changes
  echo "
$SUBMODULE_CHANGES" >> "$FILE"
}

strip_submodule_changes() {
  # looking to remove listing(s) that look like:
  #
  #     * path abbreviated-SHA1...abbreivated-SHA1 (count):
  #       > oneline commit message
  cat "$FILE" | ruby -e '
    class ParseError < RuntimeError; end

    begin
      while STDIN.readline
        if $_ =~ /^\* .+ [a-f0-9]+\.\.\.[a-f0-9]+ \(\d+\):$/

          # expect a minimum of one commit to follow
          raise ParseError unless STDIN.readline =~ /^  [<>] .+$/

          while STDIN.readline
            if $_ =~ /^  [<>] .+$/  # a commit
              next
            elsif $_ == "\n"        # an empty (separator) line
              break
            else                    # unexpected input
              raise ParseError
            end
          end
        else
          puts $_
        end
      end
    rescue EOFError
      # normal exit
    rescue ParseError
      exit 1 # effectively aborts overwriting of file
    end
  ' > $TMP_FILE && cp $TMP_FILE "$FILE"
}

case "$SOURCE" in
  commit)
    if [ -n "$SHA1" ]; then
      strip_submodule_changes
    fi
    prepend_submodule_changes
    ;;
  merge)
    # no recording done for merge commits (we assume that the parent commits
    # in the merge will have had their submodule changes recorded in them)
    ;;
  message)
    append_submodule_changes
    ;;
  squash|template)
    prepend_submodule_changes
    ;;
  *)
    prepend_submodule_changes
    ;;
esac
