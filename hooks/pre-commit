#!/usr/bin/env ruby
require 'erb'
require 'tempfile'
require 'yaml'

skip_checks = ENV.fetch('SKIP_CHECKS', '').split

CHECKS = %w[
  erb_syntax
  js_syntax
  js_console_log
  restricted_paths
  ruby_syntax
  whitespace
  yaml_syntax
  css_linter
  test_history
] - skip_checks

CHECKS.clear if skip_checks.include? 'all'

# Only check test history if repo supports it
unless FileTest.exist?('spec/support/record_results_formatter.rb')
  CHECKS.delete 'test_history'
end

SCRIPTS_PATH = '.git/hooks/scripts/'

# We run syntax checks against the version of the file that is staged in
# the index, not the one in the work tree. This class is a simple wrapper
# to make working with staged files easier.
class StagedFile
  attr_reader :contents

  def initialize path
    @original_path  = path
    @tempfile       = Tempfile.new(path.gsub('/', '_'))
    self.contents   = `git show :#{@original_path}`
  end

  # Given error output from a syntax checker, replace references to the
  # temporary file path with the original path.
  def filter_string string
    string.gsub(path, @original_path)
  end

  # The path of the temporary file on disk, suitable for feeding in to a
  # syntax checker.
  def path
    @tempfile.path
  end

  # Set or overwrite the temporary file's contents.
  #
  # This is used by the ERB syntax checker, for example, to compile
  # the template before checking.
  def contents=(contents)
    @contents = contents
    @tempfile.seek 0
    @tempfile.write @contents
    @tempfile.flush
  end
end

def bold(str)
  puts "\033[1;37m#{str}\033[0m"
end

def error(str)
  puts "\033[31m#{str}\033[0m"
end

def success(str)
  puts "\033[32m#{str}\033[0m"
end

def warning(str)
  puts "\033[33m#{str}\033[0m"
end

def notice(str)
  puts "\033[1;33m#{str}\033[0m"
end

def final_result(results)
  states = (results.transpose.first || []).uniq
  return :bad  if states.include?(:bad)
  return :stop if states.include?(:stop)
  return :good
end

def print_report(*report)
  puts report.flatten.map{|line| "    #{line}"}.join("\n")
end

WIDTH = 60 - (CHECKS.map{|s| s.length}.max || 0)
def print_incremental_result(title, status, output)
  print '.'*(WIDTH - title.length)
  case status
  when :good
    success("OK")
  when :bad
    error("FAILED")
    print_report(output)
  when :warn
    warning output
  when :stop
    warning "UH OH"
    print_report(output)
  else
    error "???"
    print_report("Check didn't return a status")
    exit(1)
  end
end

def print_result(results)
  puts
  case final_result(results)
  when :good
    success "+++ All pre-commit checks passed"
    exit 0
  when :bad
    error "!!! One or more pre-commit checks failed"
    exit 1
  when :stop
    warning "*** One or more pre-commit checks needs attention"
    warning "*** If you really want to commit, use --no-verify"
    exit 1
  end
end

def modified_files(type=nil)
  @modified_files ||= `git diff --cached --name-only --diff-filter=ACM`.split
  type ? @modified_files.select{|f| f =~ /\.#{type}$/} : @modified_files
end

def staged_files(*args)
  modified_files(*args).map { |filename| StagedFile.new(filename) }
end

def in_path?(cmd)
  system("which #{cmd} > /dev/null 2> /dev/null")
end

def check_erb_syntax
  clean = true
  output = []
  modified_files('erb').each do |file|
    staged = StagedFile.new(file)
    staged.contents = ERB.new(staged.contents, nil, '-').src
    syntax = `ruby -c #{staged.path} 2>&1`
    unless $? == 0
      output += staged.filter_string(syntax).to_a
      clean = false
    end
  end
  return (clean ? :good : :bad), output
end

JS_HINT_PATH = File.join(SCRIPTS_PATH, 'jshint.js')
JS_HINT_RUNNER_PATH = File.join(SCRIPTS_PATH, 'jshint_runner.js')
def check_js_syntax
  return :warn, "Rhino is not installed" unless in_path? 'rhino'

  staged = staged_files('js')
  return :good, nil if staged.empty?
  paths = staged.map { |s| s.path }.join(' ')

  output = `rhino -strict -f #{JS_HINT_PATH} #{JS_HINT_RUNNER_PATH} #{paths} 2>&1 | grep -v warning`
  staged.each { |s| output = s.filter_string(output) }
  return (output !~ /^ERROR/ ? :good : :bad), output
end

# https://www.pivotaltracker.com/story/show/18119495
def check_js_console_log
  staged = staged_files('js')
  return :good, nil if staged.empty?

  paths = staged.map { |s| s.path }.join(' ')
  output = `grep -n -e 'console\\.log' #{paths}`.split("\n").reject do |line|
    /^\d+:\s*\/\// =~ line ||     # Skip comments
      /ALLOW_CONSOLE_LOG/ =~ line # and lines with ALLOW_CONSOLE_LOG
  end.join("\n")
  staged.each { |s| output = s.filter_string(output) }
  return (output.empty? ? :good : :bad), output
end

CSS_LINTER_PATH = File.join(SCRIPTS_PATH, 'csslint-rhino.js')
def check_css_linter
  staged = staged_files('css')
  return :good, nil if staged.empty?

  return :warn, "Rhino is not installed" unless in_path? 'rhino'

  paths = staged.map { |s| s.path }.join(' ')

  output = `rhino #{CSS_LINTER_PATH} --quiet --format=compact #{paths} | grep 'Error - '`
  staged.each { |s| output = s.filter_string(output) }
  return (output !~ /Error - (?!Unknown @ rule)/ ? :good : :bad), output
end

RESTRICTED_PATHS = %w[
  vendor
]
def check_restricted_paths
  RESTRICTED_PATHS.each do |path|
    if !system("git diff --cached --quiet -- #{path}")
      return :stop, "changes staged under #{path}"
    end
  end
  return :good
end

def check_ruby_syntax
  clean = true
  output = []
  staged_files('rb').each do |staged|
    syntax = `ruby -c #{staged.path} 2>&1`
    unless $? == 0
      output += staged.filter_string(syntax).to_a
      clean = false
    end
  end
  return (clean ? :good : :bad), output
end

# catches trailing whitespace, conflict markers etc
def check_whitespace
  output = `git diff --check --cached`
  return ($?.exitstatus.zero? ? :good : :stop), output
end

def check_yaml_syntax
  clean = true
  output = []
  modified_files('yml').each do |file|
    staged = StagedFile.new(file)
    begin
      YAML.load_file(staged.path)
    rescue ArgumentError => e
      output << "#{e.message} parsing #{file}"
      clean = false
    end
  end
  return (clean ? :good : :bad), output
end

TEST_RESULTS_FILE = '.spec-results'
def check_test_history
  output = []
  relevant_tests = `relevant-tests -- #{modified_files.join(' ')}`.split("\n")
  unless relevant_tests.any?
    return :warn, 'No relevant tests for this change...write some?'
  end

  begin
    good_tests = File.open(TEST_RESULTS_FILE, 'r').readlines.map do |spec_file|
      spec_file.strip
    end
  rescue Errno::ENOENT
    good_tests = []
  end

  unless good_tests.any?
    return :bad,
      'The relevant tests for this change have not yet been run using `specr`'
  end

  missed_tests = (relevant_tests - good_tests)
  unless missed_tests.empty?
    output << 'The following relevant tests have not been run recently:'
    output << missed_tests.sort
    return :bad, output
  end

  # Find files modified after the tests were run
  test_time = File.mtime(TEST_RESULTS_FILE)
  untested_files = modified_files.reject do |file|
    File.mtime(file) < test_time
  end

  unless untested_files.empty?
    output << 'The following files were modified after `specr` was run.'
    output << '(their associated tests may be broken):'
    output << untested_files.sort
    return :bad, output
  end

  return :good
end

exit unless modified_files.any?

puts "Running pre-commit checks"
results = []
CHECKS.each do |check|
  title = "  Checking #{check}..."
  print title
  status, output = send("check_#{check}")
  results << [status, output]
  print_incremental_result(title, status, output)
end
print_result(results)
