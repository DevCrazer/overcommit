#!/usr/bin/env ruby
require 'erb'
require 'tempfile'
require 'yaml'

CHECKS = %w[
  braided_paths
  erb_syntax
  js_syntax
  restricted_paths
  ruby_syntax
  whitespace
  yaml_syntax
]
SCRIPTS_PATH = '.git/hooks/scripts/'

# We run syntax checks against the version of the file that is staged in
# the index, not the one in the work tree. This class is a simple wrapper
# to make working with staged files easier.
class StagedFile
  attr_reader :contents

  def initialize path
    @original_path  = path
    @tempfile       = Tempfile.new(path.gsub('/', '_'))
    self.contents   = `git show :#{@original_path}`
  end

  # Given error output from a syntax checker, replace references to the
  # temporary file path with the original path.
  def filter_string string
    string.gsub(path, @original_path)
  end

  # The path of the temporary file on disk, suitable for feeding in to a
  # syntax checker.
  def path
    @tempfile.path
  end

  # Set or overwrite the temporary file's contents.
  #
  # This is used by the ERB syntax checker, for example, to compile
  # the template before checking.
  def contents=(contents)
    @contents = contents
    @tempfile.seek 0
    @tempfile.write @contents
    @tempfile.flush
  end
end

def error(str)
  puts "\033[31m#{str}\033[0m"
end

def success(str)
  puts "\033[32m#{str}\033[0m"
end

def warning(str)
  puts "\033[33m#{str}\033[0m"
end

def final_result(results)
  states = results.transpose.first.uniq
  return :bad  if states.include?(:bad)
  return :stop if states.include?(:stop)
  return :good
end

def print_report(*report)
  puts report.flatten.map{|line| "    #{line}"}.join("\n")
end

WIDTH = 60 - CHECKS.map{|s| s.length}.max
def print_incremental_result(title, status, output)
  print '.'*(WIDTH - title.length)
  case status
  when :good
    success("OK")
  when :bad
    error("FAILED")
    print_report(output)
  when :warn
    warning output
  when :stop
    warning "UH OH"
    print_report(output)
  else
    error "???"
    print_report("Check didn't return a status")
    exit(1)
  end
end

def print_result(results)
  puts
  case final_result(results)
  when :good
    success "+++ All pre-commit checks passed"
    exit 0
  when :bad
    error "!!! One or more pre-commit checks failed"
    exit 1
  when :stop
    warning "*** One or more pre-commit checks needs attention"
    warning "*** If you really want to commit, use --no-verify"
    exit 1
  end
end

def modified_files(type=nil)
  @modified_files ||= `git diff --cached --name-only --diff-filter=ACM`.split
  type ? @modified_files.select{|f| f =~ /\.#{type}$/} : @modified_files
end

def check_braided_paths
  return :good unless File.exists?('.braids')
  braids = YAML.load_file('.braids')
  modified_braids = []
  braids.keys.each do |path|
    if !system("git diff --cached --quiet -- #{path}")
      modified_braids << path
    end
  end
  return :good if modified_braids.empty?
  return :bad, ["Braided plugins can only be updated with Braid",
                *modified_braids]
end

def check_erb_syntax
  clean = true
  output = []
  modified_files('erb').each do |file|
    staged = StagedFile.new(file)
    staged.contents = ERB.new(staged.contents, nil, '-').src
    syntax = `ruby -c #{staged.path} 2>&1`
    unless $? == 0
      output += staged.filter_string(syntax).to_a
      clean = false
    end
  end
  return (clean ? :good : :bad), output
end

JS_HINT_PATH = File.join(SCRIPTS_PATH, 'jshint.js')
JS_HINT_RUNNER_PATH = File.join(SCRIPTS_PATH, 'jshint_runner.js')
def check_js_syntax
  unless system('which rhino > /dev/null 2> /dev/null')
    return :warn, "Rhino is not installed"
  end

  files = modified_files('js')
  return :good, nil unless files.any?
  staged = files.map { |file| StagedFile.new(file) }
  paths = staged.map { |s| s.path }.join(' ')

  output = `rhino -f #{JS_HINT_PATH} #{JS_HINT_RUNNER_PATH} #{paths}`
  staged.each { |s| output = s.filter_string(output) }
  return (output !~ /^ERROR/ ? :good : :bad), output
end

RESTRICTED_PATHS = %w[
  vendor
]
def check_restricted_paths
  RESTRICTED_PATHS.each do |path|
    if !system("git diff --cached --quiet -- #{path}")
      return :stop, "changes staged under #{path}"
    end
  end
  return :good
end

def check_ruby_syntax
  clean = true
  output = []
  modified_files('rb').each do |file|
    staged = StagedFile.new(file)
    syntax = `ruby -c #{staged.path} 2>&1`
    unless $? == 0
      output += staged.filter_string(syntax).to_a
      clean = false
    end
  end
  return (clean ? :good : :bad), output
end

# catches trailing whitespace, conflict markers etc
def check_whitespace
  output = `git diff --check --cached`
  return ($?.exitstatus.zero? ? :good : :stop), output
end

def check_yaml_syntax
  clean = true
  output = []
  modified_files('yml').each do |file|
    staged = StagedFile.new(file)
    begin
      YAML.load_file(staged.path)
    rescue ArgumentError => e
      output << "#{e.message} parsing #{file}"
      clean = false
    end
  end
  return (clean ? :good : :bad), output
end

exit unless modified_files.any?

puts "Running pre-commit checks"
results = []
CHECKS.each do |check|
  title = "  Checking #{check}..."
  print title
  status, output = send("check_#{check}")
  results << [status, output]
  print_incremental_result(title, status, output)
end
print_result(results)
